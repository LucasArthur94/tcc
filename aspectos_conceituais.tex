\chapter{Aspectos Conceituais}
Neste capítulo, serão abordados os principais conceitos relacionados à parte teórica do trabalho. Em especial, serão tratadas técnicas para compreender melhor os requisitos essenciais de um sistema a ser desenvolvido, essenciais para o projeto, tanto na fase inicial, como no desenvolvimento.

\section{Representação de Requisitos}
Ao se desenvolver um sistema, existem diversas técnicas que podem ser usadas para representar os requisitos de diferentes formas. Para este trabalho, duas técnicas foram consideradas: Histórias de Usuário e Casos de Uso.

\subsection{Histórias de Usuário}
Uma das abordagens possíveis para se representar os requisitos é o uso de História de Usuário (ou \textit{User Story}):\cite{jonathanrasmusson}:

\begin{citacaoLonga}
Descrições curtas das funcionalidades que o nosso cliente
gostaria de um dia ver em seu software. Elas geralmente são escritas em pequenos cartões de índice (para nos lembrar de não tentar escrever tudo) e estão lá para nos encorajar a ir falar com nossos clientes.
\end{citacaoLonga}

O essencial em escrever boas histórias de usuário está em agregar valor para os \textit{stakeholders}. Ou seja, escrever histórias de usuário que tangem assuntos como arquitetura do sistema, linguagem de implementação, padrões de código entre outros não são boas histórias de usuário, pois salvo exceções, o cliente não vê valor em histórias desse tipo\cite{jonathanrasmusson}.

Em contrapartida, histórias sobre o comportamento do sistema com valor de produto nelas são histórias de usuário importantes para o processo de desenvolvimento. Muitas vezes, porém, histórias de usuário forçam um viés altamente técnico; nessas situações, cabe buscar a causa raiz que levou à "solução" escrita na história: histórias de usuário apresentam problemas de negócio, e não soluções técnicas.

Um bom padrão para escrever histórias de usuário está a seguir\cite{jonathanrasmusson}:

\begin{citacaoLonga}
Eu como $<$para quem é a história$>$
\\
Eu quero $<$o que ele quer$>$
\\
por causa $<$por que ele quer$>$
\end{citacaoLonga}

A vantagem de escrever histórias segundo esse modelo é que, naturalmente, elas atendem as características que definem Histórias de Usuário:

\begin{itemize}
    \item Independentes: fundamental para mudanças no projeto (que ocorrem com frequência).
    \item Negociáveis: podem sofrer alterações e inclusive serem removidas se, com o andamento do projeto, ela perder sua prioridade e tais alterações e remoções não devem afetar o andar geral das outras tarefas.
    \item Testáveis: no fluxo de negócio e na escrita de testes automatizados, assim garantimos com facilidade a qualidade do que está sendo entregue
    \item Pequenas e Estimáveis: o esforço dela pode ser previsto com antecedência, permitindo assim medidas de performance dos envolvidos.
\end{itemize}

\subsection{Casos de Uso}
Outra alternativa para documentar o que será desenvolvido no sistema são os casos de uso. Essencialmente, cada caso de uso possui um ou mais atores interagindo com o sistema. Segundo \cite{kurtbittnerianspence2002}:

\begin{citacaoLonga}
\textbf{Atores} representam as pessoas ou coisas que interagem de alguma forma com o sistema.
\\
\\
\textbf{Casos de Uso} representam as coisas de valor que o sistema executa para os atores.
\end{citacaoLonga}

\subsubsection{Uma estrutura de caso de uso\cite{ibm2011}}

\begin{enumerate}
    \item Nome: nome do Caso de Uso
    \begin{enumerate}
        \item Breve Descrição: finalidade do caso de uso
    \end{enumerate}
    \item Fluxo de Eventos: a descrição dos eventos que ocorrem no sistema, que são divididos em dois conjuntos principais.
    \begin{enumerate}
        \item Fluxo Básico: é o comportamento básico da interação entre os atores e o sistema. Não ha situações de contorno nem exceções, itens dos fluxos alternativos.
        \item Fluxos Alternativos: comportamentos diferenciados do caso de uso, podendo haver mais de um.
    \end{enumerate}
    \item Requisitos Especiais: requisito não funcional que não está contemplado no fluxo de eventos.
    \item Pré-condição: estado do sistema antes da realização do caso de uso.
    \item Pós-condição: estado do sistema após a execução.
\end{enumerate}

Resumindo, o caso de uso é uma descrição comportamental da funcionalidade descrita, servindo de contrato estabelecido de desenvolvimento do sistema.

\section{Requisitos}
Os requisitos são responsáveis por o funcionamento do software a ser desenvolvido, alinhando as expectativas dos interessados com o futuro projeto. Para encontrar esses requisitos, existe um processo definido básico, definido em \cite{kurtbittnerianspence2002}:

\begin{itemize}
    \item Definição dos \textit{stakeholders}: Encontrar todos que são afetados pelo sistema.
    \item Entendimento dos Problemas: Técnicas para consultar os \textit{stakeholders} sobre o que eles esperam que o sistema resolva e como sua existência afeta o dia-a-dia deles.
    \item Documento Visão: Unificação do entendimento do sistema, que serve como base para estabelecer o que será de fato o sistema.
\end{itemize}

\subsection{\textit{Stakeholders}}
Inicialmente, para melhor entender quem será afetado com a existência dele. foram levantados os \textit{stakeholders}. Segundo \cite{kurtbittnerianspence2002}, a definição traduzida de \textit{stakeholder} é a seguinte:

\begin{citacaoLonga}
"Um indivíduo que é materialmente afetado pelo resultado do
sistema ou o(s) projeto(s) que produzem o sistema."
\end{citacaoLonga}

Ou seja, \textit{stakeholders} não são apenas os indivíduos que efetivamente usarão o sistema, mas sim todos os impactados com sua existência. Eles são divididos em 5 grupos:

\begin{itemize}
    \item Usuários: as pessoas que efetivamente usarão o sistema.
    \item Patrocinadores: os financiadores do projeto de software que gerará o sistema.
    \item Desenvolvedores: os responsáveis por desenvolver o sistema.
    \item Autoridades: órgãos reguladores que determinam regras para o uso do sistema.
    \item Consumidores: empresas que compram esses softwares para serem usados.
\end{itemize}

Uma vez mapeado os \textit{stakeholders}, devemos entender as dores que cada um possui e o que eles esperam com o produto final a ser desenvolvido. Alguns processos são sugeridos pelo livro\cite{kurtbittnerianspence2002}, como por exemplo:

\begin{itemize}
    \item Entrevistas: entrevistar os \textit{stakeholders} e entender diretamente quais são suas dores e expectativas.
    \item Questionários: sequência de perguntas feitas à todos os \textit{stakeholders} para compreender o que cada um pensa sobre o sistema. São úteis quando há um amplo número de \textit{stakeholders} envolvidos.
    \item Grupo Focal: reunião com alguns representantes dos grupos de \textit{stakeholders} para entender e construir uma visão única sobre o projeto.
    \item Quadros de Aviso: um tipo particular de grupo focal, onde o quadro serve como unificador da visão, com a diferença de não ter todos reunidos ao mesmo tempo.
    \item \textit{Workshops}: eventos avisados com antecedência para entender melhor sobre o sistema, com a participação dos envolvidos, focando na colaboração entre eles.
    \item Revisões: reuniões informais com o intuito de revisar documentos gerados com alguns envolvidos.
    \item Encenação: uma técnica facilitadora usada em conjunto com \textit{workshops} para obter informações mais específicas ou \textit{feedbacks}.
\end{itemize}

Com essa listagem de problemas levantados pelos processos de levantamento de requisitos, finalmente partirmos para a visão unificada do processo como um todo e como o software vai atuar no processo. Para isso, é saudável a elaboração de um documento unificando os pontos de vista dos \textit{stakeholders} e estabelecendo o que de fato será o sistema a ser desenvolvido, resultando no Documento Visão.

\subsection{Documento Visão}
O Documento Visão é o responsável por unificar as visões de todos os \textit{stakeholders} sobre o sistema, centralizando todas as expectativas e definindo o escopo macro do projeto. Nele também deve constar as justificativas necessárias para a construção do sistema, explicitando possíveis concorrentes e os diferenciais do produto a ser desenvolvido.

Existem diversos modelos de Documento Visão, porém, em sua essência, atendem os seguintes tópicos\cite{kurtbittnerianspence2002}:

\begin{enumerate}
    \item Posicionamento: Como o sistema irá se posicionar no quesito de negócios? Há concorrentes que já resolvem o problema? Quais são seus diferenciais em relação a eles?
    \item \textit{Stakeholders} e usuários: Quem são os envolvidos direta e indiretamente com o desenvolvimento e a existência do sistema?
    \item Necessidades chave: Quais são as demandas que realmente precisam estar nos planos do sistema para satisfazer os envolvidos?
    \item Visão geral do produto: O que é o produto de fato? Quais são suas dependências, capacidades e alternativas ao seu desenvolvimento?
    \item Funcionalidades: Quais são as funcionalidades em alto nível do sistema, para que elas resolvam as necessidades chave listadas anteriormente?
    \item Outros requisitos do produto: Quais são os outros requisitos do sistema que não foram capturados como funcionalidades?
\end{enumerate}

Há duas formas de construção do Documento Visão, de acordo com as necessidades do projeto\cite{elisayuminakagawa2013}:
\begin{itemize}
    \item Após os processos de entendimento dos problemas: nesta situação, a sequência natural é a escrita dos Casos de Uso do sistema, de forma a documentar o que e como será entre cada funcionalidade.
    \item Após os Casos de Uso: já neste caso, o Documento Visão é gerado após à escrita dos Casos de Uso.
\end{itemize}

Segundo \cite{kurtbittnerianspence2002}, o fluxo adotado é o de construção dos Casos de Uso só após a elaboração do Documento Visão.

\section{Verificação e Validação}
Durante o desenvolvimento, devemos garantir a qualidade do que está sendo entregue. Para isso, existem os processos de verificação e validação, traduzidos do SWEBOK\cite[cap.~10, p.~6]{ieeecomputersociety2014}: "O objetivo da verificação e validação é ajudar a equipe de desenvolvimento a garantir qualidade no sistema por todo seu ciclo de vida."

Ao se desenvolver um software, é uma boa prática acompanhar se os requisitos funcionais e não funcionais estão sendo atendidos, de preferência com acompanhamento das métricas determinadas nos requisitos. Essa prática é conhecida como verificação, definida de maneira resumida pela seguinte pergunta\cite[cap. ~10, p. ~6]{ieeecomputersociety2014}: "Estamos construindo o produto corretamente?"

Além de acompanhar os requisitos propostos, é importante entender se o sistema está de acordo com as expectativas operacionais dos \textit{stakeholders}. Essa análise constante de adequação voltada aos negócios é conhecida como validação, definida pela seguinte questão\cite[cap. ~10, p. ~6]{ieeecomputersociety2014}: "Estamos construindo o produto correto?"

\subsection{Testes}
Em ambos os casos descritos acima, precisamos de técnicas para detectar erros e manter a consistência do que já foi entregue. Para isso, existe o conceito de testes, onde se buscam no sistema erros e falhas, para que possam ser corrigidas e assim garantir a qualidade e alinhamento do que foi entregue. Vale lembrar que essa bateria de testes é finita, sendo um subgrupo dos infinitos fluxos de execução do domínio\cite{ieeecomputersociety2014}.

Na escala macroscópica, temos os testes de aceitação junto aos \textit{stakeholders}, para validar a conformidade dos requisitos e a qualidade das entregas. Já para testar a arquitetura, costumam ser realizados testes de sistema. Para testar os componentes desenvolvidos do sistema, realizam-se testes de integração entre esses componentes. E, por fim, o código escrito para cada componente elaborado é testado pelos testes de unidade.

Ao desenvolver um sistema, uma boa prática é executar a suíte de testes construída a cada nova funcionalidade adicionada e/ou modificada, pois só assim é possível garantir a qualidade do que já foi entregue, detectando erros causados por essas modificações. Para auxiliar nessa boa prática, em especial para os testes menores, é automatizar a execução deles, o que economiza tempo de uma pessoa dedicada à função de testador.
